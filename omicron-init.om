# polymorphic functions
def id = ~A:*{^x:A{x}};
def const = ~A:*{~B:*{^x:A{^y:B{x}}}};

# fixed point combinator
def tri = ~A:*{~B:*{
  ^f:(A->B)->(A->B){^x:Rec(^T:*{T->(A->B)}){
    f(^y:A{unfold[Rec(^T:*{T->(A->B)})](x)(x)(y)})
  }}
}};
def fix = ~A:*{~B:*{
  ^f:(A->B)->(A->B){
    tri[A][B](f)(fold[Rec(^T:*{T->(A->B)})](tri[A][B](f)))
  }
}};

# hungry function
# unfold[Hungry](..(unfold[Hungry](hungry_func(0)))(1)))..) : Hungry
type def Hungry = Rec(^T:*{Int->T});
def hungry_func = fix[Int][Hungry](
  ^f:Int->Hungry{^x:Int{
    fold[Hungry](f)
  }}
);

# Monad
type def Monad = ^M:*->*{
  ${ fmap : @A:*{@B:*{(A->B)->M(A)->M(B)}}
  ,  pure : @A:*{A->M(A)}
  ,  join : @A:*{M(M(A))->M(A)}
  }
};
def bind = ~M:*->*{~A:*{~B:*{
  ^monad:Monad(M){^m:M(A){^f:A->M(B){
    monad.join[B](monad.fmap[A][M(B)](f)(m))
  }}}
}}};

# Maybe
type def Maybe = ^A:*{
  ${ bind_maybe : @B:*{(A->B)->B->B} }
};
def just = ~A:*{
  ^x:A{
    ${ bind_maybe = ~B:*{^f:A->B{^g:B{f(x)}}} }
  }
};
def nothing = ~A:*{
  ${ bind_maybe = ~B:*{^f:A->B{^g:B{g}}} }
};
def maybe_monad = ${
  fmap = ~A:*{~B:*{
    ^f:A->B{^m:Maybe(A){
      m.bind_maybe[Maybe(B)]
        (^x:A{just[B](f(x))})
        (nothing[B])
    }}
  }},
  pure = just,
  join = ~A:*{
    ^m:Maybe(Maybe(A)){
      m.bind_maybe[Maybe(A)]
        (^x:Maybe(A){x})
        (nothing[A])
    }
  }
};

# List
type def List = ^A:*{
  Rec(^LA:*{
    ${ bind_list : @B:*{B->(A->LA->B)->B} }
  })
};
def nil = ~A:*{
  fold[List(A)](
    ${ bind_list = ~B:*{^f:B{^g:A->List(A)->B{f}}} }
  )
};
def cons = ~A:*{
  ^x:A{^xs:List(A){
    fold[List(A)](
      ${ bind_list = ~B:*{^f:B{^g:A->List(A)->B{g(x)(xs)}}}}
    )
  }}
};
